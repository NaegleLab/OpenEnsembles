
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>scipy.sparse.linalg.eigen.arpack.arpack &#8212; OpenEnsembles 0 documentation</title>
    <link rel="stylesheet" href="../../../../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
  </head>
  <body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../../../../../../index.html">OpenEnsembles 0 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scipy.sparse.linalg.eigen.arpack.arpack</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Find a few eigenvectors and eigenvalues of a matrix.</span>


<span class="sd">Uses ARPACK: http://www.caam.rice.edu/software/ARPACK/</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Wrapper implementation notes</span>
<span class="c1">#</span>
<span class="c1"># ARPACK Entry Points</span>
<span class="c1"># -------------------</span>
<span class="c1"># The entry points to ARPACK are</span>
<span class="c1"># - (s,d)seupd : single and double precision symmetric matrix</span>
<span class="c1"># - (s,d,c,z)neupd: single,double,complex,double complex general matrix</span>
<span class="c1"># This wrapper puts the *neupd (general matrix) interfaces in eigs()</span>
<span class="c1"># and the *seupd (symmetric matrix) in eigsh().</span>
<span class="c1"># There is no Hermetian complex/double complex interface.</span>
<span class="c1"># To find eigenvalues of a Hermetian matrix you</span>
<span class="c1"># must use eigs() and not eigsh()</span>
<span class="c1"># It might be desirable to handle the Hermetian case differently</span>
<span class="c1"># and, for example, return real eigenvalues.</span>

<span class="c1"># Number of eigenvalues returned and complex eigenvalues</span>
<span class="c1"># ------------------------------------------------------</span>
<span class="c1"># The ARPACK nonsymmetric real and double interface (s,d)naupd return</span>
<span class="c1"># eigenvalues and eigenvectors in real (float,double) arrays.</span>
<span class="c1"># Since the eigenvalues and eigenvectors are, in general, complex</span>
<span class="c1"># ARPACK puts the real and imaginary parts in consecutive entries</span>
<span class="c1"># in real-valued arrays.   This wrapper puts the real entries</span>
<span class="c1"># into complex data types and attempts to return the requested eigenvalues</span>
<span class="c1"># and eigenvectors.</span>


<span class="c1"># Solver modes</span>
<span class="c1"># ------------</span>
<span class="c1"># ARPACK and handle shifted and shift-inverse computations</span>
<span class="c1"># for eigenvalues by providing a shift (sigma) and a solver.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;eigs&#39;</span><span class="p">,</span> <span class="s1">&#39;eigsh&#39;</span><span class="p">,</span> <span class="s1">&#39;svds&#39;</span><span class="p">,</span> <span class="s1">&#39;ArpackError&#39;</span><span class="p">,</span> <span class="s1">&#39;ArpackNoConvergence&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_arpack</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg.interface</span> <span class="k">import</span> <span class="n">aslinearoperator</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">eye</span><span class="p">,</span> <span class="n">isspmatrix</span><span class="p">,</span> <span class="n">isspmatrix_csr</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">lu_factor</span><span class="p">,</span> <span class="n">lu_solve</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.sputils</span> <span class="k">import</span> <span class="n">isdense</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">import</span> <span class="n">gmres</span><span class="p">,</span> <span class="n">splu</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="k">import</span> <span class="n">_aligned_zeros</span>
<span class="kn">from</span> <span class="nn">scipy._lib._threadsafety</span> <span class="k">import</span> <span class="n">ReentrancyLock</span>


<span class="n">_type_conv</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">}</span>
<span class="n">_ndigits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>

<span class="n">DNAUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Normal exit.&quot;</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;Maximum number of iterations taken. &quot;</span>
       <span class="s2">&quot;All possible eigenvalues of OP has been found. IPARAM(5) &quot;</span>
       <span class="s2">&quot;returns the number of wanted converged Ritz values.&quot;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;No longer an informational error. Deprecated starting &quot;</span>
       <span class="s2">&quot;with release 2 of ARPACK.&quot;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;No shifts could be applied during a cycle of the &quot;</span>
       <span class="s2">&quot;Implicitly restarted Arnoldi iteration. One possibility &quot;</span>
       <span class="s2">&quot;is to increase the size of NCV relative to NEV. &quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NEV must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NCV-NEV &gt;= 2 and less than or equal to N.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;The maximum number of Arnoldi update iterations allowed &quot;</span>
        <span class="s2">&quot;must be greater than zero.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot; WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LR&#39;, &#39;SR&#39;, &#39;LI&#39;, &#39;SI&#39;&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;BMAT must be one of &#39;I&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;Length of private work array WORKL is not sufficient.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;Error return from LAPACK eigenvalue calculation;&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="s2">&quot;Starting vector is zero.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3,4.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;IPARAM(1) must be equal to 0 or 1.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">13</span><span class="p">:</span> <span class="s2">&quot;NEV and WHICH = &#39;BE&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">9999</span><span class="p">:</span> <span class="s2">&quot;Could not build an Arnoldi factorization. &quot;</span>
           <span class="s2">&quot;IPARAM(5) returns the size of the current Arnoldi &quot;</span>
           <span class="s2">&quot;factorization. The user is advised to check that &quot;</span>
           <span class="s2">&quot;enough workspace and array storage has been allocated.&quot;</span>
<span class="p">}</span>

<span class="n">SNAUPD_ERRORS</span> <span class="o">=</span> <span class="n">DNAUPD_ERRORS</span>

<span class="n">ZNAUPD_ERRORS</span> <span class="o">=</span> <span class="n">DNAUPD_ERRORS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">ZNAUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3.&quot;</span>

<span class="n">CNAUPD_ERRORS</span> <span class="o">=</span> <span class="n">ZNAUPD_ERRORS</span>

<span class="n">DSAUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Normal exit.&quot;</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;Maximum number of iterations taken. &quot;</span>
       <span class="s2">&quot;All possible eigenvalues of OP has been found.&quot;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;No longer an informational error. Deprecated starting with &quot;</span>
       <span class="s2">&quot;release 2 of ARPACK.&quot;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;No shifts could be applied during a cycle of the Implicitly &quot;</span>
       <span class="s2">&quot;restarted Arnoldi iteration. One possibility is to increase &quot;</span>
       <span class="s2">&quot;the size of NCV relative to NEV. &quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NEV must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NCV must be greater than NEV and less than or equal to N.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;The maximum number of Arnoldi update iterations allowed &quot;</span>
        <span class="s2">&quot;must be greater than zero.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LA&#39;, &#39;SA&#39; or &#39;BE&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;BMAT must be one of &#39;I&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;Length of private work array WORKL is not sufficient.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;Error return from trid. eigenvalue calculation; &quot;</span>
        <span class="s2">&quot;Informational error from LAPACK routine dsteqr .&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="s2">&quot;Starting vector is zero.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3,4,5.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;IPARAM(1) must be equal to 0 or 1.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">13</span><span class="p">:</span> <span class="s2">&quot;NEV and WHICH = &#39;BE&#39; are incompatible. &quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">9999</span><span class="p">:</span> <span class="s2">&quot;Could not build an Arnoldi factorization. &quot;</span>
           <span class="s2">&quot;IPARAM(5) returns the size of the current Arnoldi &quot;</span>
           <span class="s2">&quot;factorization. The user is advised to check that &quot;</span>
           <span class="s2">&quot;enough workspace and array storage has been allocated.&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">SSAUPD_ERRORS</span> <span class="o">=</span> <span class="n">DSAUPD_ERRORS</span>

<span class="n">DNEUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Normal exit.&quot;</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;The Schur form computed by LAPACK routine dlahqr &quot;</span>
       <span class="s2">&quot;could not be reordered by LAPACK routine dtrsen. &quot;</span>
       <span class="s2">&quot;Re-enter subroutine dneupd  with IPARAM(5)NCV and &quot;</span>
       <span class="s2">&quot;increase the size of the arrays DR and DI to have &quot;</span>
       <span class="s2">&quot;dimension at least dimension NCV and allocate at least NCV &quot;</span>
       <span class="s2">&quot;columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
       <span class="s2">&quot;the same space. Please notify the authors if this error&quot;</span>
       <span class="s2">&quot;occurs.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NEV must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NCV-NEV &gt;= 2 and less than or equal to N.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LR&#39;, &#39;SR&#39;, &#39;LI&#39;, &#39;SI&#39;&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;BMAT must be one of &#39;I&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;Error return from calculation of a real Schur form. &quot;</span>
        <span class="s2">&quot;Informational error from LAPACK routine dlahqr .&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="s2">&quot;Error return from calculation of eigenvectors. &quot;</span>
        <span class="s2">&quot;Informational error from LAPACK routine dtrevc.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3,4.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;HOWMNY = &#39;S&#39; not yet implemented&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">13</span><span class="p">:</span> <span class="s2">&quot;HOWMNY must be one of &#39;A&#39; or &#39;P&#39; if RVEC = .true.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">14</span><span class="p">:</span> <span class="s2">&quot;DNAUPD  did not find any eigenvalues to sufficient &quot;</span>
         <span class="s2">&quot;accuracy.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">15</span><span class="p">:</span> <span class="s2">&quot;DNEUPD got a different count of the number of converged &quot;</span>
         <span class="s2">&quot;Ritz values than DNAUPD got.  This indicates the user &quot;</span>
         <span class="s2">&quot;probably made an error in passing data from DNAUPD to &quot;</span>
         <span class="s2">&quot;DNEUPD or that the data was modified before entering &quot;</span>
         <span class="s2">&quot;DNEUPD&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">SNEUPD_ERRORS</span> <span class="o">=</span> <span class="n">DNEUPD_ERRORS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">SNEUPD_ERRORS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The Schur form computed by LAPACK routine slahqr &quot;</span>
                    <span class="s2">&quot;could not be reordered by LAPACK routine strsen . &quot;</span>
                    <span class="s2">&quot;Re-enter subroutine dneupd  with IPARAM(5)=NCV and &quot;</span>
                    <span class="s2">&quot;increase the size of the arrays DR and DI to have &quot;</span>
                    <span class="s2">&quot;dimension at least dimension NCV and allocate at least &quot;</span>
                    <span class="s2">&quot;NCV columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
                    <span class="s2">&quot;the same space. Please notify the authors if this error &quot;</span>
                    <span class="s2">&quot;occurs.&quot;</span><span class="p">)</span>
<span class="n">SNEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s2">&quot;accuracy.&quot;</span><span class="p">)</span>
<span class="n">SNEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SNEUPD got a different count of the number of &quot;</span>
                      <span class="s2">&quot;converged Ritz values than SNAUPD got.  This indicates &quot;</span>
                      <span class="s2">&quot;the user probably made an error in passing data from &quot;</span>
                      <span class="s2">&quot;SNAUPD to SNEUPD or that the data was modified before &quot;</span>
                      <span class="s2">&quot;entering SNEUPD&quot;</span><span class="p">)</span>

<span class="n">ZNEUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Normal exit.&quot;</span><span class="p">,</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;The Schur form computed by LAPACK routine csheqr &quot;</span>
                    <span class="s2">&quot;could not be reordered by LAPACK routine ztrsen. &quot;</span>
                    <span class="s2">&quot;Re-enter subroutine zneupd with IPARAM(5)=NCV and &quot;</span>
                    <span class="s2">&quot;increase the size of the array D to have &quot;</span>
                    <span class="s2">&quot;dimension at least dimension NCV and allocate at least &quot;</span>
                    <span class="s2">&quot;NCV columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
                    <span class="s2">&quot;the same space. Please notify the authors if this error &quot;</span>
                    <span class="s2">&quot;occurs.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N must be positive.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NEV must be positive.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NCV-NEV &gt;= 1 and less than or equal to N.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LR&#39;, &#39;SR&#39;, &#39;LI&#39;, &#39;SI&#39;&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;BMAT must be one of &#39;I&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;Error return from LAPACK eigenvalue calculation. &quot;</span>
                     <span class="s2">&quot;This should never happened.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="s2">&quot;Error return from calculation of eigenvectors. &quot;</span>
                     <span class="s2">&quot;Informational error from LAPACK routine ztrevc.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;HOWMNY = &#39;S&#39; not yet implemented&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">13</span><span class="p">:</span> <span class="s2">&quot;HOWMNY must be one of &#39;A&#39; or &#39;P&#39; if RVEC = .true.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">14</span><span class="p">:</span> <span class="s2">&quot;ZNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s2">&quot;accuracy.&quot;</span><span class="p">,</span>
                 <span class="o">-</span><span class="mi">15</span><span class="p">:</span> <span class="s2">&quot;ZNEUPD got a different count of the number of &quot;</span>
                      <span class="s2">&quot;converged Ritz values than ZNAUPD got.  This &quot;</span>
                      <span class="s2">&quot;indicates the user probably made an error in passing &quot;</span>
                      <span class="s2">&quot;data from ZNAUPD to ZNEUPD or that the data was &quot;</span>
                      <span class="s2">&quot;modified before entering ZNEUPD&quot;</span>
                 <span class="p">}</span>

<span class="n">CNEUPD_ERRORS</span> <span class="o">=</span> <span class="n">ZNEUPD_ERRORS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">CNEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s2">&quot;accuracy.&quot;</span><span class="p">)</span>
<span class="n">CNEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CNEUPD got a different count of the number of &quot;</span>
                      <span class="s2">&quot;converged Ritz values than CNAUPD got.  This indicates &quot;</span>
                      <span class="s2">&quot;the user probably made an error in passing data from &quot;</span>
                      <span class="s2">&quot;CNAUPD to CNEUPD or that the data was modified before &quot;</span>
                      <span class="s2">&quot;entering CNEUPD&quot;</span><span class="p">)</span>

<span class="n">DSEUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Normal exit.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NEV must be positive.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NCV must be greater than NEV and less than or equal to N.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LA&#39;, &#39;SA&#39; or &#39;BE&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;BMAT must be one of &#39;I&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">8</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Error return from trid. eigenvalue calculation; &quot;</span>
         <span class="s2">&quot;Information error from LAPACK routine dsteqr.&quot;</span><span class="p">),</span>
    <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="s2">&quot;Starting vector is zero.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) must be 1,2,3,4,5.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;NEV and WHICH = &#39;BE&#39; are incompatible.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">14</span><span class="p">:</span> <span class="s2">&quot;DSAUPD  did not find any eigenvalues to sufficient accuracy.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">15</span><span class="p">:</span> <span class="s2">&quot;HOWMNY must be one of &#39;A&#39; or &#39;S&#39; if RVEC = .true.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">16</span><span class="p">:</span> <span class="s2">&quot;HOWMNY = &#39;S&#39; not yet implemented&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">17</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;DSEUPD  got a different count of the number of converged &quot;</span>
          <span class="s2">&quot;Ritz values than DSAUPD  got.  This indicates the user &quot;</span>
          <span class="s2">&quot;probably made an error in passing data from DSAUPD  to &quot;</span>
          <span class="s2">&quot;DSEUPD  or that the data was modified before entering  &quot;</span>
          <span class="s2">&quot;DSEUPD.&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">SSEUPD_ERRORS</span> <span class="o">=</span> <span class="n">DSEUPD_ERRORS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">SSEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SSAUPD  did not find any eigenvalues &quot;</span>
                      <span class="s2">&quot;to sufficient accuracy.&quot;</span><span class="p">)</span>
<span class="n">SSEUPD_ERRORS</span><span class="p">[</span><span class="o">-</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SSEUPD  got a different count of the number of &quot;</span>
                      <span class="s2">&quot;converged &quot;</span>
                      <span class="s2">&quot;Ritz values than SSAUPD  got.  This indicates the user &quot;</span>
                      <span class="s2">&quot;probably made an error in passing data from SSAUPD  to &quot;</span>
                      <span class="s2">&quot;SSEUPD  or that the data was modified before entering  &quot;</span>
                      <span class="s2">&quot;SSEUPD.&quot;</span><span class="p">)</span>

<span class="n">_SAUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">DSAUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">SSAUPD_ERRORS</span><span class="p">}</span>
<span class="n">_NAUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">DNAUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">SNAUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">ZNAUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">CNAUPD_ERRORS</span><span class="p">}</span>
<span class="n">_SEUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">DSEUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">SSEUPD_ERRORS</span><span class="p">}</span>
<span class="n">_NEUPD_ERRORS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">DNEUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">SNEUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">ZNEUPD_ERRORS</span><span class="p">,</span>
                 <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">CNEUPD_ERRORS</span><span class="p">}</span>

<span class="c1"># accepted values of parameter WHICH in _SEUPD</span>
<span class="n">_SEUPD_WHICH</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="s1">&#39;LA&#39;</span><span class="p">,</span> <span class="s1">&#39;SA&#39;</span><span class="p">,</span> <span class="s1">&#39;BE&#39;</span><span class="p">]</span>

<span class="c1"># accepted values of parameter WHICH in _NAUPD</span>
<span class="n">_NEUPD_WHICH</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="s1">&#39;LR&#39;</span><span class="p">,</span> <span class="s1">&#39;SR&#39;</span><span class="p">,</span> <span class="s1">&#39;LI&#39;</span><span class="p">,</span> <span class="s1">&#39;SI&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ArpackError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ARPACK error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="n">_NAUPD_ERRORS</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">infodict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Unknown error&quot;</span><span class="p">)</span>
        <span class="ne">RuntimeError</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ARPACK error </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">ArpackNoConvergence</span><span class="p">(</span><span class="n">ArpackError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ARPACK iteration did not converge</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    eigenvalues : ndarray</span>
<span class="sd">        Partial result. Converged eigenvalues.</span>
<span class="sd">    eigenvectors : ndarray</span>
<span class="sd">        Partial result. Converged eigenvectors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">):</span>
        <span class="n">ArpackError</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">msg</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">eigenvectors</span>


<span class="k">def</span> <span class="nf">choose_ncv</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose number of lanczos vectors based on target number</span>
<span class="sd">    of singular/eigen values and vectors to compute, k.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ArpackParams</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be positive, k=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxiter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxiter</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">maxiter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maxiter must be positive, maxiter=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">maxiter</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fdFD&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix type must be &#39;f&#39;, &#39;d&#39;, &#39;F&#39;, or &#39;D&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ARPACK overwrites its initial resid,  make a copy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">info</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ARPACK will use a random initial vector.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
            <span class="n">info</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#sigma not used</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>

        <span class="k">if</span> <span class="n">ncv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncv</span> <span class="o">=</span> <span class="n">choose_ncv</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">ncv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ncv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">ncv</span><span class="p">),</span> <span class="n">tp</span><span class="p">)</span>  <span class="c1"># holds Ritz vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>

        <span class="c1"># set solver mode and parameters</span>
        <span class="n">ishfts</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ishfts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">=</span> <span class="n">maxiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">=</span> <span class="n">ncv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which</span> <span class="o">=</span> <span class="n">which</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_raise_no_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No convergence (</span><span class="si">%d</span><span class="s2"> iterations, </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> eigenvectors converged)&quot;</span>
        <span class="n">k_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">num_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ev</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ArpackError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">k_ok</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">raise</span> <span class="n">ArpackNoConvergence</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_iter</span><span class="p">,</span> <span class="n">k_ok</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">ev</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SymmetricArpackParams</span><span class="p">(</span><span class="n">_ArpackParams</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">matvec</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M_matvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">Minv_matvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># The following modes are supported:</span>
        <span class="c1">#  mode = 1:</span>
        <span class="c1">#    Solve the standard eigenvalue problem:</span>
        <span class="c1">#      A*x = lambda*x :</span>
        <span class="c1">#       A - symmetric</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = None [not used]</span>
        <span class="c1">#       Minv_matvec = None [not used]</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 2:</span>
        <span class="c1">#    Solve the general eigenvalue problem:</span>
        <span class="c1">#      A*x = lambda*M*x</span>
        <span class="c1">#       A - symmetric</span>
        <span class="c1">#       M - symmetric positive definite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = left multiplication by M</span>
        <span class="c1">#       Minv_matvec = left multiplication by M^-1</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 3:</span>
        <span class="c1">#    Solve the general eigenvalue problem in shift-invert mode:</span>
        <span class="c1">#      A*x = lambda*M*x</span>
        <span class="c1">#       A - symmetric</span>
        <span class="c1">#       M - symmetric positive semi-definite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = None [not used]</span>
        <span class="c1">#       M_matvec    = left multiplication by M</span>
        <span class="c1">#                     or None, if M is the identity</span>
        <span class="c1">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 4:</span>
        <span class="c1">#    Solve the general eigenvalue problem in Buckling mode:</span>
        <span class="c1">#      A*x = lambda*AG*x</span>
        <span class="c1">#       A  - symmetric positive semi-definite</span>
        <span class="c1">#       AG - symmetric indefinite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = None [not used]</span>
        <span class="c1">#       Minv_matvec = left multiplication by [A-sigma*AG]^-1</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 5:</span>
        <span class="c1">#    Solve the general eigenvalue problem in Cayley-transformed mode:</span>
        <span class="c1">#      A*x = lambda*M*x</span>
        <span class="c1">#       A - symmetric</span>
        <span class="c1">#       M - symmetric positive semi-definite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = left multiplication by M</span>
        <span class="c1">#                     or None, if M is the identity</span>
        <span class="c1">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M_matvec cannot be specified for mode=1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec cannot be specified for mode=1&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=2&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M_matvec must be specified for mode=2&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified for mode=2&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Minv_matvec</span><span class="p">(</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPb</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">M_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must not be specified for mode=3&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified for mode=3&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Minv_matvec</span><span class="p">(</span><span class="n">M_matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">M_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=4&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M_matvec must not be specified for mode=4&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified for mode=4&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=5&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified for mode=5&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_matvec</span> <span class="o">=</span> <span class="n">matvec</span>

            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Minv_matvec</span><span class="p">(</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Minv_matvec</span><span class="p">(</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                                                <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">M_matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">M_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode=</span><span class="si">%i</span><span class="s2"> not implemented&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">which</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SEUPD_WHICH</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;which must be one of </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_SEUPD_WHICH</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be less than ndim(A), k=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">_ArpackParams</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                               <span class="n">ncv</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ncv must be k&lt;ncv&lt;=n, ncv=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">)</span>

        <span class="c1"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workd</span> <span class="o">=</span> <span class="n">_aligned_zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workl</span> <span class="o">=</span> <span class="n">_aligned_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>

        <span class="n">ltr</span> <span class="o">=</span> <span class="n">_type_conv</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ltr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrix is not real-valued.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_solver</span> <span class="o">=</span> <span class="n">_arpack</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">ltr</span> <span class="o">+</span> <span class="s1">&#39;saupd&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_extract</span> <span class="o">=</span> <span class="n">_arpack</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">ltr</span> <span class="o">+</span> <span class="s1">&#39;seupd&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iterate_infodict</span> <span class="o">=</span> <span class="n">_SAUPD_ERRORS</span><span class="p">[</span><span class="n">ltr</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_infodict</span> <span class="o">=</span> <span class="n">_SEUPD_ERRORS</span><span class="p">[</span><span class="n">ltr</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

        <span class="n">xslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">yslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># initialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># compute y = Op*x</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">Bxslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">Ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_matvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="n">Ax</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">Bxslice</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Bxslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">Bxslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ARPACK requested user shifts.  Assure ISHIFT==0&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_no_convergence</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArpackError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iterate_infodict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="p">):</span>
        <span class="n">rvec</span> <span class="o">=</span> <span class="n">return_eigenvectors</span>
        <span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">howmny</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>  <span class="c1"># return all eigenvectors</span>
        <span class="n">sselect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">)</span>  <span class="c1"># unused</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">ierr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_extract</span><span class="p">(</span><span class="n">rvec</span><span class="p">,</span> <span class="n">howmny</span><span class="p">,</span> <span class="n">sselect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ierr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArpackError</span><span class="p">(</span><span class="n">ierr</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_infodict</span><span class="p">)</span>
        <span class="n">k_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="n">k_ok</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_ok</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_eigenvectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>


<span class="k">class</span> <span class="nc">_UnsymmetricArpackParams</span><span class="p">(</span><span class="n">_ArpackParams</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">matvec</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M_matvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">Minv_matvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># The following modes are supported:</span>
        <span class="c1">#  mode = 1:</span>
        <span class="c1">#    Solve the standard eigenvalue problem:</span>
        <span class="c1">#      A*x = lambda*x</span>
        <span class="c1">#       A - square matrix</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = None [not used]</span>
        <span class="c1">#       Minv_matvec = None [not used]</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 2:</span>
        <span class="c1">#    Solve the generalized eigenvalue problem:</span>
        <span class="c1">#      A*x = lambda*M*x</span>
        <span class="c1">#       A - square matrix</span>
        <span class="c1">#       M - symmetric, positive semi-definite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = left multiplication by A</span>
        <span class="c1">#       M_matvec    = left multiplication by M</span>
        <span class="c1">#       Minv_matvec = left multiplication by M^-1</span>
        <span class="c1">#</span>
        <span class="c1">#  mode = 3,4:</span>
        <span class="c1">#    Solve the general eigenvalue problem in shift-invert mode:</span>
        <span class="c1">#      A*x = lambda*M*x</span>
        <span class="c1">#       A - square matrix</span>
        <span class="c1">#       M - symmetric, positive semi-definite</span>
        <span class="c1">#    Arguments should be</span>
        <span class="c1">#       matvec      = None [not used]</span>
        <span class="c1">#       M_matvec    = left multiplication by M</span>
        <span class="c1">#                     or None, if M is the identity</span>
        <span class="c1">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="c1">#    if A is real and mode==3, use the real part of Minv_matvec</span>
        <span class="c1">#    if A is real and mode==4, use the imag part of Minv_matvec</span>
        <span class="c1">#    if A is complex and mode==3,</span>
        <span class="c1">#       use real and imag parts of Minv_matvec</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M_matvec cannot be specified for mode=1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec cannot be specified for mode=1&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified for mode=2&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M_matvec must be specified for mode=2&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified for mode=2&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Minv_matvec</span><span class="p">(</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPb</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">M_matvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matvec must be specified &quot;</span>
                                 <span class="s2">&quot;for mode in (3,4)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Minv_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv_matvec must be specified &quot;</span>
                                 <span class="s2">&quot;for mode in (3,4)&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span> <span class="o">=</span> <span class="n">matvec</span>
            <span class="k">if</span> <span class="n">tp</span> <span class="ow">in</span> <span class="s1">&#39;DF&#39;</span><span class="p">:</span>  <span class="c1"># complex type</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="n">Minv_matvec</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode=4 invalid for complex A&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># real type</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Minv_matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Minv_matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">M_matvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">M_matvec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="n">M_matvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode=</span><span class="si">%i</span><span class="s2"> not implemented&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">which</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_NEUPD_WHICH</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter which must be one of </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_NEUPD_WHICH</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be less than ndim(A)-1, k=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">_ArpackParams</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                               <span class="n">ncv</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ncv must be k+1&lt;ncv&lt;=n, ncv=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">)</span>

        <span class="c1"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workd</span> <span class="o">=</span> <span class="n">_aligned_zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workl</span> <span class="o">=</span> <span class="n">_aligned_zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>

        <span class="n">ltr</span> <span class="o">=</span> <span class="n">_type_conv</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_solver</span> <span class="o">=</span> <span class="n">_arpack</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">ltr</span> <span class="o">+</span> <span class="s1">&#39;naupd&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_extract</span> <span class="o">=</span> <span class="n">_arpack</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">ltr</span> <span class="o">+</span> <span class="s1">&#39;neupd&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iterate_infodict</span> <span class="o">=</span> <span class="n">_NAUPD_ERRORS</span><span class="p">[</span><span class="n">ltr</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_infodict</span> <span class="o">=</span> <span class="n">_NEUPD_ERRORS</span><span class="p">[</span><span class="n">ltr</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="ow">in</span> <span class="s1">&#39;FD&#39;</span><span class="p">:</span>
            <span class="c1"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">_aligned_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="ow">in</span> <span class="s1">&#39;fd&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ido</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

        <span class="n">xslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">yslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># initialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># compute y = Op*x</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Bxslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">Bxslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">yslice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">[</span><span class="n">xslice</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ido</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ARPACK requested user shifts.  Assure ISHIFT==0&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_no_convergence</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArpackError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iterate_infodict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="p">):</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">howmny</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>  <span class="c1"># return all eigenvectors</span>
        <span class="n">sselect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">)</span>  <span class="c1"># unused</span>
        <span class="n">sigmar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">sigmai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">workev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="ow">in</span> <span class="s1">&#39;fd&#39;</span><span class="p">:</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>
            <span class="n">di</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>
            <span class="n">zr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">)</span>
            <span class="n">dr</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">zr</span><span class="p">,</span> <span class="n">ierr</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_extract</span><span class="p">(</span><span class="n">return_eigenvectors</span><span class="p">,</span>
                       <span class="n">howmny</span><span class="p">,</span> <span class="n">sselect</span><span class="p">,</span> <span class="n">sigmar</span><span class="p">,</span> <span class="n">sigmai</span><span class="p">,</span> <span class="n">workev</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ierr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArpackError</span><span class="p">(</span><span class="n">ierr</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_infodict</span><span class="p">)</span>
            <span class="n">nreturned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># number of good eigenvalues returned</span>

            <span class="c1"># Build complex eigenvalues from real and imaginary parts</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">di</span>

            <span class="c1"># Arrange the eigenvectors: complex eigenvectors are stored as</span>
            <span class="c1"># real,imaginary in consecutive columns</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">zr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

            <span class="c1"># The ARPACK nonsymmetric real and double interface (s,d)naupd</span>
            <span class="c1"># return eigenvalues and eigenvectors in real (float,double)</span>
            <span class="c1"># arrays.</span>

            <span class="c1"># Efficiency: this should check that return_eigenvectors == True</span>
            <span class="c1">#  before going through this construction.</span>
            <span class="k">if</span> <span class="n">sigmai</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="c1"># check if complex</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># this is a complex conjugate pair with eigenvalues</span>
                        <span class="c1"># in consecutive columns</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                            <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#last eigenvalue is complex: the imaginary part of</span>
                            <span class="c1"># the eigenvector has not been returned</span>
                            <span class="c1">#this can only happen if nreturned &gt; k, so we&#39;ll</span>
                            <span class="c1"># throw out this case.</span>
                            <span class="n">nreturned</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># real matrix, mode 3 or 4, imag(sigma) is nonzero:</span>
                <span class="c1"># see remark 3 in &lt;s,d&gt;neupd.f</span>
                <span class="c1"># Build complex eigenvalues from real and imaginary parts</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                            <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span>
                                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span>
                                    <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                                            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">zr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))))</span>
                            <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#last eigenvalue is complex: the imaginary part of</span>
                            <span class="c1"># the eigenvector has not been returned</span>
                            <span class="c1">#this can only happen if nreturned &gt; k, so we&#39;ll</span>
                            <span class="c1"># throw out this case.</span>
                            <span class="n">nreturned</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Now we have k+1 possible eigenvalues and eigenvectors</span>
            <span class="c1"># Return the ones specified by the keyword &quot;which&quot;</span>

            <span class="k">if</span> <span class="n">nreturned</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="c1"># we got less or equal as many eigenvalues we wanted</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="n">nreturned</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nreturned</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we got one extra eigenvalue (likely a cc pair, but which?)</span>
                <span class="c1"># cut at approx precision for sorting</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">_ndigits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;LR&#39;</span><span class="p">,</span> <span class="s1">&#39;SR&#39;</span><span class="p">]:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;LI&#39;</span><span class="p">,</span> <span class="s1">&#39;SI&#39;</span><span class="p">]:</span>
                    <span class="c1"># for LI,SI ARPACK returns largest,smallest</span>
                    <span class="c1"># abs(imaginary) why?</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rd</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;LR&#39;</span><span class="p">,</span> <span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="s1">&#39;LI&#39;</span><span class="p">]:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:]]</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SR&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="s1">&#39;SI&#39;</span><span class="p">]:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">ind</span><span class="p">[:</span><span class="n">k</span><span class="p">]]</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">[:</span><span class="n">k</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># complex is so much simpler...</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">ierr</span> <span class="o">=</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">_arpack_extract</span><span class="p">(</span><span class="n">return_eigenvectors</span><span class="p">,</span>
                           <span class="n">howmny</span><span class="p">,</span> <span class="n">sselect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">workev</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">which</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipntr</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">workd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ierr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArpackError</span><span class="p">(</span><span class="n">ierr</span><span class="p">,</span> <span class="n">infodict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_infodict</span><span class="p">)</span>

            <span class="n">k_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iparam</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="n">k_ok</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_ok</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_eigenvectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">aslinearoperator</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">m</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">return</span> <span class="n">m</span>


<span class="k">class</span> <span class="nc">SpLuInv</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SpLuInv:</span>
<span class="sd">       helper class to repeatedly solve M*x=b</span>
<span class="sd">       using a sparse LU-decopposition of M</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span> <span class="o">=</span> <span class="n">splu</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isreal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># careful here: splu.solve will throw away imaginary</span>
        <span class="c1"># part of x if M is real</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreal</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                    <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">LuInv</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LuInv:</span>
<span class="sd">       helper class to repeatedly solve M*x=b</span>
<span class="sd">       using an LU-decomposition of M</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span> <span class="o">=</span> <span class="n">lu_factor</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lu_solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M_lu</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IterInv</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IterInv:</span>
<span class="sd">       helper class to repeatedly solve M*x=b</span>
<span class="sd">       using an iterative method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">ifunc</span><span class="o">=</span><span class="n">gmres</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># when tol=0, ARPACK uses machine tolerance as calculated</span>
            <span class="c1"># by LAPACK&#39;s _LAMCH function.  We should match this</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span> <span class="o">=</span> <span class="n">ifunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in inverting M: function &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> did not converge (info = </span><span class="si">%i</span><span class="s2">).&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">b</span>


<span class="k">class</span> <span class="nc">IterOpInv</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IterOpInv:</span>
<span class="sd">       helper class to repeatedly solve [A-sigma*M]*x = b</span>
<span class="sd">       using an iterative method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ifunc</span><span class="o">=</span><span class="n">gmres</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># when tol=0, ARPACK uses machine tolerance as calculated</span>
            <span class="c1"># by LAPACK&#39;s _LAMCH function.  We should match this</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span> <span class="o">=</span> <span class="n">ifunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>

        <span class="k">def</span> <span class="nf">mult_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">mult_func_M_None</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">x</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">mult_func_M_None</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">mult_func_M_None</span><span class="p">,</span>
                                     <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">mult_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OP</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">mult_func</span><span class="p">,</span>
                                     <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in inverting [A-sigma*M]: function &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> did not converge (info = </span><span class="si">%i</span><span class="s2">).&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ifunc</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">OP</span><span class="o">.</span><span class="n">dtype</span>


<span class="k">def</span> <span class="nf">get_inv_matvec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">isdense</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LuInv</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
    <span class="k">elif</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isspmatrix_csr</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="ow">and</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">SpLuInv</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IterInv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>


<span class="k">def</span> <span class="nf">get_OPinv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_inv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="n">symmetric</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#M is the identity matrix</span>
        <span class="k">if</span> <span class="n">isdense</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
            <span class="n">A</span><span class="o">.</span><span class="n">flat</span><span class="p">[::</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sigma</span>
            <span class="k">return</span> <span class="n">LuInv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">elif</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">symmetric</span> <span class="ow">and</span> <span class="n">isspmatrix_csr</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">SpLuInv</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">tocsc</span><span class="p">())</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IterOpInv</span><span class="p">(</span><span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
                              <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">isdense</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">isdense</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">M</span><span class="p">))):</span>
            <span class="k">return</span> <span class="n">IterOpInv</span><span class="p">(</span><span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
                              <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">),</span>
                              <span class="n">sigma</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">elif</span> <span class="n">isdense</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isdense</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">LuInv</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">OP</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">M</span>
            <span class="k">if</span> <span class="n">symmetric</span> <span class="ow">and</span> <span class="n">isspmatrix_csr</span><span class="p">(</span><span class="n">OP</span><span class="p">):</span>
                <span class="n">OP</span> <span class="o">=</span> <span class="n">OP</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">SpLuInv</span><span class="p">(</span><span class="n">OP</span><span class="o">.</span><span class="n">tocsc</span><span class="p">())</span><span class="o">.</span><span class="n">matvec</span>


<span class="c1"># ARPACK is not threadsafe or reentrant (SAVE variables), so we need a</span>
<span class="c1"># lock and a re-entering check.</span>
<span class="n">_ARPACK_LOCK</span> <span class="o">=</span> <span class="n">ReentrancyLock</span><span class="p">(</span><span class="s2">&quot;Nested calls to eigs/eighs not allowed: &quot;</span>
                              <span class="s2">&quot;ARPACK is not re-entrant&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">eigs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
         <span class="n">Minv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OPinv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OPpart</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find k eigenvalues and eigenvectors of the square matrix A.</span>

<span class="sd">    Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem</span>
<span class="sd">    for w[i] eigenvalues with corresponding eigenvectors x[i].</span>

<span class="sd">    If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the</span>
<span class="sd">    generalized eigenvalue problem for w[i] eigenvalues</span>
<span class="sd">    with corresponding eigenvectors x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : ndarray, sparse matrix or LinearOperator</span>
<span class="sd">        An array, sparse matrix, or LinearOperator representing</span>
<span class="sd">        the operation ``A * x``, where A is a real or complex square matrix.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        The number of eigenvalues and eigenvectors desired.</span>
<span class="sd">        `k` must be smaller than N. It is not possible to compute all</span>
<span class="sd">        eigenvectors of a matrix.</span>
<span class="sd">    M : ndarray, sparse matrix or LinearOperator, optional</span>
<span class="sd">        An array, sparse matrix, or LinearOperator representing</span>
<span class="sd">        the operation M*x for the generalized eigenvalue problem</span>

<span class="sd">            A * x = w * M * x.</span>

<span class="sd">        M must represent a real, symmetric matrix if A is real, and must</span>
<span class="sd">        represent a complex, hermitian matrix if A is complex. For best</span>
<span class="sd">        results, the data type of M should be the same as that of A.</span>
<span class="sd">        Additionally:</span>

<span class="sd">            If `sigma` is None, M is positive definite</span>

<span class="sd">            If sigma is specified, M is positive semi-definite</span>

<span class="sd">        If sigma is None, eigs requires an operator to compute the solution</span>
<span class="sd">        of the linear equation ``M * x = b``.  This is done internally via a</span>
<span class="sd">        (sparse) LU decomposition for an explicit matrix M, or via an</span>
<span class="sd">        iterative solver for a general linear operator.  Alternatively,</span>
<span class="sd">        the user can supply the matrix or operator Minv, which gives</span>
<span class="sd">        ``x = Minv * b = M^-1 * b``.</span>
<span class="sd">    sigma : real or complex, optional</span>
<span class="sd">        Find eigenvalues near sigma using shift-invert mode.  This requires</span>
<span class="sd">        an operator to compute the solution of the linear system</span>
<span class="sd">        ``[A - sigma * M] * x = b``, where M is the identity matrix if</span>
<span class="sd">        unspecified. This is computed internally via a (sparse) LU</span>
<span class="sd">        decomposition for explicit matrices A &amp; M, or via an iterative</span>
<span class="sd">        solver if either A or M is a general linear operator.</span>
<span class="sd">        Alternatively, the user can supply the matrix or operator OPinv,</span>
<span class="sd">        which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.</span>
<span class="sd">        For a real matrix A, shift-invert can either be done in imaginary</span>
<span class="sd">        mode or real mode, specified by the parameter OPpart (&#39;r&#39; or &#39;i&#39;).</span>
<span class="sd">        Note that when sigma is specified, the keyword &#39;which&#39; (below)</span>
<span class="sd">        refers to the shifted eigenvalues ``w&#39;[i]`` where:</span>

<span class="sd">            If A is real and OPpart == &#39;r&#39; (default),</span>
<span class="sd">              ``w&#39;[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]``.</span>

<span class="sd">            If A is real and OPpart == &#39;i&#39;,</span>
<span class="sd">              ``w&#39;[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]``.</span>

<span class="sd">            If A is complex, ``w&#39;[i] = 1/(w[i]-sigma)``.</span>

<span class="sd">    v0 : ndarray, optional</span>
<span class="sd">        Starting vector for iteration.</span>
<span class="sd">        Default: random</span>
<span class="sd">    ncv : int, optional</span>
<span class="sd">        The number of Lanczos vectors generated</span>
<span class="sd">        `ncv` must be greater than `k`; it is recommended that ``ncv &gt; 2*k``.</span>
<span class="sd">        Default: ``min(n, max(2*k + 1, 20))``</span>
<span class="sd">    which : str, [&#39;LM&#39; | &#39;SM&#39; | &#39;LR&#39; | &#39;SR&#39; | &#39;LI&#39; | &#39;SI&#39;], optional</span>
<span class="sd">        Which `k` eigenvectors and eigenvalues to find:</span>

<span class="sd">            &#39;LM&#39; : largest magnitude</span>

<span class="sd">            &#39;SM&#39; : smallest magnitude</span>

<span class="sd">            &#39;LR&#39; : largest real part</span>

<span class="sd">            &#39;SR&#39; : smallest real part</span>

<span class="sd">            &#39;LI&#39; : largest imaginary part</span>

<span class="sd">            &#39;SI&#39; : smallest imaginary part</span>

<span class="sd">        When sigma != None, &#39;which&#39; refers to the shifted eigenvalues w&#39;[i]</span>
<span class="sd">        (see discussion in &#39;sigma&#39;, above).  ARPACK is generally better</span>
<span class="sd">        at finding large values than small values.  If small eigenvalues are</span>
<span class="sd">        desired, consider using shift-invert mode for better performance.</span>
<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of Arnoldi update iterations allowed</span>
<span class="sd">        Default: ``n*10``</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Relative accuracy for eigenvalues (stopping criterion)</span>
<span class="sd">        The default value of 0 implies machine precision.</span>
<span class="sd">    return_eigenvectors : bool, optional</span>
<span class="sd">        Return eigenvectors (True) in addition to eigenvalues</span>
<span class="sd">    Minv : ndarray, sparse matrix or LinearOperator, optional</span>
<span class="sd">        See notes in M, above.</span>
<span class="sd">    OPinv : ndarray, sparse matrix or LinearOperator, optional</span>
<span class="sd">        See notes in sigma, above.</span>
<span class="sd">    OPpart : {&#39;r&#39; or &#39;i&#39;}, optional</span>
<span class="sd">        See notes in sigma, above</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Array of k eigenvalues.</span>
<span class="sd">    v : ndarray</span>
<span class="sd">        An array of `k` eigenvectors.</span>
<span class="sd">        ``v[:, i]`` is the eigenvector corresponding to the eigenvalue w[i].</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ArpackNoConvergence</span>
<span class="sd">        When the requested convergence is not obtained.</span>
<span class="sd">        The currently converged eigenvalues and eigenvectors can be found</span>
<span class="sd">        as ``eigenvalues`` and ``eigenvectors`` attributes of the exception</span>
<span class="sd">        object.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eigsh : eigenvalues and eigenvectors for symmetric matrix A</span>
<span class="sd">    svds : singular value decomposition for a matrix A</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is a wrapper to the ARPACK [1]_ SNEUPD, DNEUPD, CNEUPD,</span>
<span class="sd">    ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to</span>
<span class="sd">    find the eigenvalues and eigenvectors [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/</span>
<span class="sd">    .. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:</span>
<span class="sd">       Solution of Large Scale Eigenvalue Problems by Implicitly Restarted</span>
<span class="sd">       Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find 6 eigenvectors of the identity matrix:</span>

<span class="sd">    &gt;&gt;&gt; import scipy.sparse as sparse</span>
<span class="sd">    &gt;&gt;&gt; id = np.eye(13)</span>
<span class="sd">    &gt;&gt;&gt; vals, vecs = sparse.linalg.eigs(id, k=6)</span>
<span class="sd">    &gt;&gt;&gt; vals</span>
<span class="sd">    array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])</span>
<span class="sd">    &gt;&gt;&gt; vecs.shape</span>
<span class="sd">    (13, 6)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected square matrix (shape=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong M dimensions </span><span class="si">%s</span><span class="s1">, should be </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;M does not have the same type precision as A. &#39;</span>
                          <span class="s1">&#39;This may adversely affect ARPACK convergence&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k=</span><span class="si">%d</span><span class="s2"> must be between 1 and ndim(A)-1=</span><span class="si">%d</span><span class="s2">&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>

        <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPinv should not be specified &quot;</span>
                             <span class="s2">&quot;with sigma = None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">OPpart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPpart should not be specified with &quot;</span>
                             <span class="s2">&quot;sigma = None or complex A&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#standard eigenvalue problem</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv should not be &quot;</span>
                                 <span class="s2">&quot;specified with M = None.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#general eigenvalue problem</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_inv_matvec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Minv</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">Minv</span><span class="p">)</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">Minv</span><span class="o">.</span><span class="n">matvec</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#sigma is not None: shift-invert mode</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">OPpart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPpart should not be specified &quot;</span>
                                 <span class="s2">&quot;with sigma=None or complex A&quot;</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">OPpart</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">OPpart</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">OPpart</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPpart cannot be &#39;i&#39; if sigma is real&quot;</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPpart must be one of (&#39;r&#39;,&#39;i&#39;)&quot;</span><span class="p">)</span>

        <span class="n">matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv should not be specified when sigma is&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_OPinv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                           <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">OPinv</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">OPinv</span><span class="p">)</span>
            <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">OPinv</span><span class="o">.</span><span class="n">matvec</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">_UnsymmetricArpackParams</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="n">matvec</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                                      <span class="n">M_matvec</span><span class="p">,</span> <span class="n">Minv_matvec</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                      <span class="n">ncv</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">_ARPACK_LOCK</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">params</span><span class="o">.</span><span class="n">converged</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">iterate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">params</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">return_eigenvectors</span><span class="p">)</span>


<div class="viewcode-block" id="eigsh"><a class="viewcode-back" href="../../../../../../scipy-sphinx-theme-master/test_autodoc_4.html#scipy.sparse.linalg.eigsh">[docs]</a><span class="k">def</span> <span class="nf">eigsh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_eigenvectors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">Minv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OPinv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find k eigenvalues and eigenvectors of the real symmetric square matrix</span>
<span class="sd">    or complex hermitian matrix A.</span>

<span class="sd">    Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem for</span>
<span class="sd">    w[i] eigenvalues with corresponding eigenvectors x[i].</span>

<span class="sd">    If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the</span>
<span class="sd">    generalized eigenvalue problem for w[i] eigenvalues</span>
<span class="sd">    with corresponding eigenvectors x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : An N x N matrix, array, sparse matrix, or LinearOperator representing</span>
<span class="sd">        the operation A * x, where A is a real symmetric matrix</span>
<span class="sd">        For buckling mode (see below) A must additionally be positive-definite</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        The number of eigenvalues and eigenvectors desired.</span>
<span class="sd">        `k` must be smaller than N. It is not possible to compute all</span>
<span class="sd">        eigenvectors of a matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : array</span>
<span class="sd">        Array of k eigenvalues</span>
<span class="sd">    v : array</span>
<span class="sd">        An array representing the `k` eigenvectors.  The column ``v[:, i]`` is</span>
<span class="sd">        the eigenvector corresponding to the eigenvalue ``w[i]``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    M : An N x N matrix, array, sparse matrix, or linear operator representing</span>
<span class="sd">        the operation M * x for the generalized eigenvalue problem</span>

<span class="sd">            A * x = w * M * x.</span>

<span class="sd">        M must represent a real, symmetric matrix if A is real, and must</span>
<span class="sd">        represent a complex, hermitian matrix if A is complex. For best</span>
<span class="sd">        results, the data type of M should be the same as that of A.</span>
<span class="sd">        Additionally:</span>

<span class="sd">            If sigma is None, M is symmetric positive definite</span>

<span class="sd">            If sigma is specified, M is symmetric positive semi-definite</span>

<span class="sd">            In buckling mode, M is symmetric indefinite.</span>

<span class="sd">        If sigma is None, eigsh requires an operator to compute the solution</span>
<span class="sd">        of the linear equation ``M * x = b``. This is done internally via a</span>
<span class="sd">        (sparse) LU decomposition for an explicit matrix M, or via an</span>
<span class="sd">        iterative solver for a general linear operator.  Alternatively,</span>
<span class="sd">        the user can supply the matrix or operator Minv, which gives</span>
<span class="sd">        ``x = Minv * b = M^-1 * b``.</span>
<span class="sd">    sigma : real</span>
<span class="sd">        Find eigenvalues near sigma using shift-invert mode.  This requires</span>
<span class="sd">        an operator to compute the solution of the linear system</span>
<span class="sd">        `[A - sigma * M] x = b`, where M is the identity matrix if</span>
<span class="sd">        unspecified.  This is computed internally via a (sparse) LU</span>
<span class="sd">        decomposition for explicit matrices A &amp; M, or via an iterative</span>
<span class="sd">        solver if either A or M is a general linear operator.</span>
<span class="sd">        Alternatively, the user can supply the matrix or operator OPinv,</span>
<span class="sd">        which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.</span>
<span class="sd">        Note that when sigma is specified, the keyword &#39;which&#39; refers to</span>
<span class="sd">        the shifted eigenvalues ``w&#39;[i]`` where:</span>

<span class="sd">            if mode == &#39;normal&#39;, ``w&#39;[i] = 1 / (w[i] - sigma)``.</span>

<span class="sd">            if mode == &#39;cayley&#39;, ``w&#39;[i] = (w[i] + sigma) / (w[i] - sigma)``.</span>

<span class="sd">            if mode == &#39;buckling&#39;, ``w&#39;[i] = w[i] / (w[i] - sigma)``.</span>

<span class="sd">        (see further discussion in &#39;mode&#39; below)</span>
<span class="sd">    v0 : ndarray, optional</span>
<span class="sd">        Starting vector for iteration.</span>
<span class="sd">        Default: random</span>
<span class="sd">    ncv : int, optional</span>
<span class="sd">        The number of Lanczos vectors generated ncv must be greater than k and</span>
<span class="sd">        smaller than n; it is recommended that ``ncv &gt; 2*k``.</span>
<span class="sd">        Default: ``min(n, max(2*k + 1, 20))``</span>
<span class="sd">    which : str [&#39;LM&#39; | &#39;SM&#39; | &#39;LA&#39; | &#39;SA&#39; | &#39;BE&#39;]</span>
<span class="sd">        If A is a complex hermitian matrix, &#39;BE&#39; is invalid.</span>
<span class="sd">        Which `k` eigenvectors and eigenvalues to find:</span>

<span class="sd">            &#39;LM&#39; : Largest (in magnitude) eigenvalues</span>

<span class="sd">            &#39;SM&#39; : Smallest (in magnitude) eigenvalues</span>

<span class="sd">            &#39;LA&#39; : Largest (algebraic) eigenvalues</span>

<span class="sd">            &#39;SA&#39; : Smallest (algebraic) eigenvalues</span>

<span class="sd">            &#39;BE&#39; : Half (k/2) from each end of the spectrum</span>

<span class="sd">        When k is odd, return one more (k/2+1) from the high end.</span>
<span class="sd">        When sigma != None, &#39;which&#39; refers to the shifted eigenvalues ``w&#39;[i]``</span>
<span class="sd">        (see discussion in &#39;sigma&#39;, above).  ARPACK is generally better</span>
<span class="sd">        at finding large values than small values.  If small eigenvalues are</span>
<span class="sd">        desired, consider using shift-invert mode for better performance.</span>
<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of Arnoldi update iterations allowed</span>
<span class="sd">        Default: ``n*10``</span>
<span class="sd">    tol : float</span>
<span class="sd">        Relative accuracy for eigenvalues (stopping criterion).</span>
<span class="sd">        The default value of 0 implies machine precision.</span>
<span class="sd">    Minv : N x N matrix, array, sparse matrix, or LinearOperator</span>
<span class="sd">        See notes in M, above</span>
<span class="sd">    OPinv : N x N matrix, array, sparse matrix, or LinearOperator</span>
<span class="sd">        See notes in sigma, above.</span>
<span class="sd">    return_eigenvectors : bool</span>
<span class="sd">        Return eigenvectors (True) in addition to eigenvalues</span>
<span class="sd">    mode : string [&#39;normal&#39; | &#39;buckling&#39; | &#39;cayley&#39;]</span>
<span class="sd">        Specify strategy to use for shift-invert mode.  This argument applies</span>
<span class="sd">        only for real-valued A and sigma != None.  For shift-invert mode,</span>
<span class="sd">        ARPACK internally solves the eigenvalue problem</span>
<span class="sd">        ``OP * x&#39;[i] = w&#39;[i] * B * x&#39;[i]``</span>
<span class="sd">        and transforms the resulting Ritz vectors x&#39;[i] and Ritz values w&#39;[i]</span>
<span class="sd">        into the desired eigenvectors and eigenvalues of the problem</span>
<span class="sd">        ``A * x[i] = w[i] * M * x[i]``.</span>
<span class="sd">        The modes are as follows:</span>

<span class="sd">            &#39;normal&#39; :</span>
<span class="sd">                OP = [A - sigma * M]^-1 * M,</span>
<span class="sd">                B = M,</span>
<span class="sd">                w&#39;[i] = 1 / (w[i] - sigma)</span>

<span class="sd">            &#39;buckling&#39; :</span>
<span class="sd">                OP = [A - sigma * M]^-1 * A,</span>
<span class="sd">                B = A,</span>
<span class="sd">                w&#39;[i] = w[i] / (w[i] - sigma)</span>

<span class="sd">            &#39;cayley&#39; :</span>
<span class="sd">                OP = [A - sigma * M]^-1 * [A + sigma * M],</span>
<span class="sd">                B = M,</span>
<span class="sd">                w&#39;[i] = (w[i] + sigma) / (w[i] - sigma)</span>

<span class="sd">        The choice of mode will affect which eigenvalues are selected by</span>
<span class="sd">        the keyword &#39;which&#39;, and can also impact the stability of</span>
<span class="sd">        convergence (see [2] for a discussion)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ArpackNoConvergence</span>
<span class="sd">        When the requested convergence is not obtained.</span>

<span class="sd">        The currently converged eigenvalues and eigenvectors can be found</span>
<span class="sd">        as ``eigenvalues`` and ``eigenvectors`` attributes of the exception</span>
<span class="sd">        object.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A</span>
<span class="sd">    svds : singular value decomposition for a matrix A</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is a wrapper to the ARPACK [1]_ SSEUPD and DSEUPD</span>
<span class="sd">    functions which use the Implicitly Restarted Lanczos Method to</span>
<span class="sd">    find the eigenvalues and eigenvectors [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/</span>
<span class="sd">    .. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:</span>
<span class="sd">       Solution of Large Scale Eigenvalue Problems by Implicitly Restarted</span>
<span class="sd">       Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.sparse as sparse</span>
<span class="sd">    &gt;&gt;&gt; id = np.eye(13)</span>
<span class="sd">    &gt;&gt;&gt; vals, vecs = sparse.linalg.eigsh(id, k=6)</span>
<span class="sd">    &gt;&gt;&gt; vals</span>
<span class="sd">    array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])</span>
<span class="sd">    &gt;&gt;&gt; vecs.shape</span>
<span class="sd">    (13, 6)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># complex hermitian matrices should be solved with eigs</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode=</span><span class="si">%s</span><span class="s2"> cannot be used with &quot;</span>
                             <span class="s2">&quot;complex matrix A&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;BE&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;which=&#39;BE&#39; cannot be used with complex matrix A&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;LA&#39;</span><span class="p">:</span>
            <span class="n">which</span> <span class="o">=</span> <span class="s1">&#39;LR&#39;</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;SA&#39;</span><span class="p">:</span>
            <span class="n">which</span> <span class="o">=</span> <span class="s1">&#39;SR&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="p">,</span>
                   <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                   <span class="n">return_eigenvectors</span><span class="o">=</span><span class="n">return_eigenvectors</span><span class="p">,</span> <span class="n">Minv</span><span class="o">=</span><span class="n">Minv</span><span class="p">,</span>
                   <span class="n">OPinv</span><span class="o">=</span><span class="n">OPinv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_eigenvectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected square matrix (shape=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong M dimensions </span><span class="si">%s</span><span class="s1">, should be </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;M does not have the same type precision as A. &#39;</span>
                          <span class="s1">&#39;This may adversely affect ARPACK convergence&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be between 1 and the order of the &quot;</span>
                         <span class="s2">&quot;square input matrix.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">matvec</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">matvec</span>

        <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OPinv should not be specified &quot;</span>
                             <span class="s2">&quot;with sigma = None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#standard eigenvalue problem</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv should not be &quot;</span>
                                 <span class="s2">&quot;specified with M = None.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#general eigenvalue problem</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_inv_matvec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Minv</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">Minv</span><span class="p">)</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">Minv</span><span class="o">.</span><span class="n">matvec</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># sigma is not None: shift-invert mode</span>
        <span class="k">if</span> <span class="n">Minv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minv should not be specified when sigma is&quot;</span><span class="p">)</span>

        <span class="c1"># normal mode</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_OPinv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                               <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">OPinv</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">OPinv</span><span class="p">)</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">OPinv</span><span class="o">.</span><span class="n">matvec</span>
            <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">M_matvec</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">matvec</span>

        <span class="c1"># buckling mode</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;buckling&#39;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_OPinv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                               <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">OPinv</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
            <span class="n">matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
            <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># cayley-transform mode</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;cayley&#39;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
            <span class="k">if</span> <span class="n">OPinv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">get_OPinv_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                               <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Minv_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">OPinv</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>
            <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">M_matvec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M_matvec</span> <span class="o">=</span> <span class="n">_aslinearoperator_with_dtype</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span>

        <span class="c1"># unrecognized mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized mode &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">_SymmetricArpackParams</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="n">matvec</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                                    <span class="n">M_matvec</span><span class="p">,</span> <span class="n">Minv_matvec</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                    <span class="n">ncv</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">_ARPACK_LOCK</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">params</span><span class="o">.</span><span class="n">converged</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">iterate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">params</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">return_eigenvectors</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_augmented_orthonormal_cols</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># extract the shape of the x array</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># create the expanded array and copy x into it</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[:,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="c1"># do some modified gram schmidt to add k random orthonormal vectors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="c1"># sample a random initial vector</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># subtract projections onto the existing unit length vectors</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">i</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">-=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span> <span class="o">*</span> <span class="n">u</span>
        <span class="c1"># normalize v</span>
        <span class="n">v</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span>
        <span class="c1"># add v into the output array</span>
        <span class="n">y</span><span class="p">[:,</span> <span class="n">m</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># return the expanded array</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_augmented_orthonormal_rows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_augmented_orthonormal_cols</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_herm</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_singular_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the largest k singular values/vectors for a sparse matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : {sparse matrix, LinearOperator}</span>
<span class="sd">        Array to compute the SVD on, of shape (M, N)</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Number of singular values and vectors to compute.</span>
<span class="sd">        Must be 1 &lt;= k &lt; min(A.shape).</span>
<span class="sd">    ncv : int, optional</span>
<span class="sd">        The number of Lanczos vectors generated</span>
<span class="sd">        ncv must be greater than k+1 and smaller than n;</span>
<span class="sd">        it is recommended that ncv &gt; 2*k</span>
<span class="sd">        Default: ``min(n, max(2*k + 1, 20))``</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for singular values. Zero (default) means machine precision.</span>
<span class="sd">    which : str, [&#39;LM&#39; | &#39;SM&#39;], optional</span>
<span class="sd">        Which `k` singular values to find:</span>

<span class="sd">            - &#39;LM&#39; : largest singular values</span>
<span class="sd">            - &#39;SM&#39; : smallest singular values</span>

<span class="sd">        .. versionadded:: 0.12.0</span>
<span class="sd">    v0 : ndarray, optional</span>
<span class="sd">        Starting vector for iteration, of length min(A.shape). Should be an</span>
<span class="sd">        (approximate) left singular vector if N &gt; M and a right singular</span>
<span class="sd">        vector otherwise.</span>
<span class="sd">        Default: random</span>

<span class="sd">        .. versionadded:: 0.12.0</span>
<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of iterations.</span>

<span class="sd">        .. versionadded:: 0.12.0</span>
<span class="sd">    return_singular_vectors : bool or str, optional</span>
<span class="sd">        - True: return singular vectors (True) in addition to singular values.</span>

<span class="sd">        .. versionadded:: 0.12.0</span>

<span class="sd">        - &quot;u&quot;: only return the u matrix, without computing vh (if N &gt; M).</span>
<span class="sd">        - &quot;vh&quot;: only return the vh matrix, without computing u (if N &lt;= M).</span>

<span class="sd">        .. versionadded:: 0.16.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : ndarray, shape=(M, k)</span>
<span class="sd">        Unitary matrix having left singular vectors as columns.</span>
<span class="sd">        If `return_singular_vectors` is &quot;vh&quot;, this variable is not computed,</span>
<span class="sd">        and None is returned instead.</span>
<span class="sd">    s : ndarray, shape=(k,)</span>
<span class="sd">        The singular values.</span>
<span class="sd">    vt : ndarray, shape=(k, N)</span>
<span class="sd">        Unitary matrix having right singular vectors as rows.</span>
<span class="sd">        If `return_singular_vectors` is &quot;u&quot;, this variable is not computed,</span>
<span class="sd">        and None is returned instead.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a naive implementation using ARPACK as an eigensolver</span>
<span class="sd">    on A.H * A or A * A.H, depending on which one is more efficient.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">LinearOperator</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be between 1 and min(A.shape), k=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">LinearOperator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">X_dot</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">matvec</span>
            <span class="n">X_matmat</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">matmat</span>
            <span class="n">XH_dot</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">rmatvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_dot</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">rmatvec</span>
            <span class="n">XH_dot</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">matvec</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">dtype</span>

            <span class="c1"># A^H * V; works around lack of LinearOperator.adjoint.</span>
            <span class="c1"># XXX This can be slow!</span>
            <span class="k">def</span> <span class="nf">X_matmat</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">rmatvec</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">T</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">X_dot</span> <span class="o">=</span> <span class="n">X_matmat</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span>
            <span class="n">XH_dot</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XH_dot</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span>
            <span class="n">X_dot</span> <span class="o">=</span> <span class="n">X_matmat</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span>

    <span class="k">def</span> <span class="nf">matvec_XH_X</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">XH_dot</span><span class="p">(</span><span class="n">X_dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">XH_X</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">matvec</span><span class="o">=</span><span class="n">matvec_XH_X</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

    <span class="c1"># Get a low rank approximation of the implicitly defined gramian matrix.</span>
    <span class="c1"># This is not a stable way to approach the problem.</span>
    <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">XH_X</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                  <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="p">)</span>

    <span class="c1"># In &#39;LM&#39; mode try to be clever about small eigenvalues.</span>
    <span class="c1"># Otherwise in &#39;SM&#39; mode do not try to be clever.</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;LM&#39;</span><span class="p">:</span>

        <span class="c1"># Gramian matrices have real non-negative eigenvalues.</span>
        <span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">eigvals</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Use the sophisticated detection of small eigenvalues from pinvh.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">eigvec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="n">E3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="n">E6</span><span class="p">}</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>

        <span class="c1"># Get a mask indicating which eigenpairs are not degenerately tiny,</span>
        <span class="c1"># and create the re-ordered array of thresholded singular values.</span>
        <span class="n">above_cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">eigvals</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">nlarge</span> <span class="o">=</span> <span class="n">above_cutoff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nsmall</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">nlarge</span>
        <span class="n">slarge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eigvals</span><span class="p">[</span><span class="n">above_cutoff</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[:</span><span class="n">nlarge</span><span class="p">]</span> <span class="o">=</span> <span class="n">slarge</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_singular_vectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">vlarge</span> <span class="o">=</span> <span class="n">eigvec</span><span class="p">[:,</span> <span class="n">above_cutoff</span><span class="p">]</span>
            <span class="n">ularge</span> <span class="o">=</span> <span class="n">X_matmat</span><span class="p">(</span><span class="n">vlarge</span><span class="p">)</span> <span class="o">/</span> <span class="n">slarge</span> <span class="k">if</span> <span class="n">return_singular_vectors</span> <span class="o">!=</span> <span class="s1">&#39;vh&#39;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vhlarge</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">vlarge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ularge</span> <span class="o">=</span> <span class="n">eigvec</span><span class="p">[:,</span> <span class="n">above_cutoff</span><span class="p">]</span>
            <span class="n">vhlarge</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">X_matmat</span><span class="p">(</span><span class="n">ularge</span><span class="p">)</span> <span class="o">/</span> <span class="n">slarge</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_singular_vectors</span> <span class="o">!=</span> <span class="s1">&#39;u&#39;</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">_augmented_orthonormal_cols</span><span class="p">(</span><span class="n">ularge</span><span class="p">,</span> <span class="n">nsmall</span><span class="p">)</span> <span class="k">if</span> <span class="n">ularge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">vh</span> <span class="o">=</span> <span class="n">_augmented_orthonormal_rows</span><span class="p">(</span><span class="n">vhlarge</span><span class="p">,</span> <span class="n">nsmall</span><span class="p">)</span> <span class="k">if</span> <span class="n">vhlarge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;SM&#39;</span><span class="p">:</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_singular_vectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">eigvec</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">X_matmat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span> <span class="k">if</span> <span class="n">return_singular_vectors</span> <span class="o">!=</span> <span class="s1">&#39;vh&#39;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vh</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">eigvec</span>
            <span class="n">vh</span> <span class="o">=</span> <span class="n">_herm</span><span class="p">(</span><span class="n">X_matmat</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_singular_vectors</span> <span class="o">!=</span> <span class="s1">&#39;u&#39;</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;which must be either &#39;LM&#39; or &#39;SM&#39;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../OpenEnsembles.html">The OpenEnsembles Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../finishing.html">Finishing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../cooccurrence.html">Cooccurrence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../validation.html">Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../clustering_algorithms.html">Clustering Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../transforms.html">Transformations</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../../../../../../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../../../../../../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../../../../../../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Naegle Lab.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>